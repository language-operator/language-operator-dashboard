import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { k8sClient } from '@/lib/k8s-client'
import { db } from '@/lib/db'
import { requirePermission } from '@/lib/permissions'
import { getUserOrganization } from '@/lib/organization-context'
import { LanguagePersona, LanguagePersonaListParams, LanguagePersonaFormData } from '@/types/persona'
import { safeValidateLanguagePersona } from '@/lib/validation'

// GET /api/personas - List all personas for user's organization  
export async function GET(request: NextRequest) {
  try {
    // Get user's selected organization (replaces broken memberships[0] pattern)
    const { user, organization, userRole } = await getUserOrganization(request)
    
    const hasPermission = await requirePermission(user.id, organization.id, 'view')
    if (!hasPermission) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })
    }

    const url = new URL(request.url)
    const params: LanguagePersonaListParams = {
      page: parseInt(url.searchParams.get('page') || '1'),
      limit: parseInt(url.searchParams.get('limit') || '50'),
      sortBy: (url.searchParams.get('sortBy') as any) || 'name',
      sortOrder: (url.searchParams.get('sortOrder') as any) || 'asc',
      search: url.searchParams.get('search') || undefined,
      tone: url.searchParams.getAll('tone') || undefined,
      phase: url.searchParams.getAll('phase') || undefined,
    }

    const response = await k8sClient.listLanguagePersonas(organization.namespace)
    // Fix: Response is direct from k8s API, not wrapped in { data: ... }
    const personas = (response as any)?.body?.items || (response as any)?.items || []

    // Apply filtering
    let filteredPersonas = personas.filter((persona: LanguagePersona) => {
      if (params.search) {
        const searchLower = params.search.toLowerCase()
        const nameMatch = persona.metadata.name?.toLowerCase().includes(searchLower)
        const displayNameMatch = persona.spec.displayName?.toLowerCase().includes(searchLower)
        if (!nameMatch && !displayNameMatch) return false
      }
      
      if (params.tone && params.tone.length > 0) {
        if (!params.tone.includes(persona.spec.tone || '')) return false
      }
      
      if (params.phase && params.phase.length > 0) {
        if (!params.phase.includes(persona.status?.phase || '')) return false
      }
      
      return true
    })

    // Sort and paginate
    const startIndex = ((params.page || 1) - 1) * (params.limit || 50)
    const endIndex = startIndex + (params.limit || 50)
    const paginatedPersonas = filteredPersonas.slice(startIndex, endIndex)

    return NextResponse.json({
      success: true,
      data: paginatedPersonas,
      total: filteredPersonas.length,
      page: params.page || 1,
      limit: params.limit || 50,
    })

  } catch (error) {
    console.error('Error fetching personas:', error)
    return NextResponse.json({ error: 'Failed to fetch personas' }, { status: 500 })
  }
}

// POST /api/personas - Create a new persona
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.email) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const user = await db.user.findUnique({
      where: { email: session.user.email },
      include: { memberships: { include: { organization: true } } },
    })

    if (!user || user.memberships.length === 0) {
      return NextResponse.json({ error: 'No organization found' }, { status: 404 })
    }

    const organization = user.memberships[0].organization
    
    const hasPermission = await requirePermission(user.id, organization.id, 'create')
    if (!hasPermission) {
      return NextResponse.json({ error: 'Insufficient permissions' }, { status: 403 })
    }

    const formData: LanguagePersonaFormData = await request.json()

    const persona: LanguagePersona = {
      apiVersion: 'langop.io/v1alpha1',
      kind: 'LanguagePersona',
      metadata: {
        name: formData.name,
        namespace: organization.namespace,
        labels: {
          'langop.io/organization-id': organization.id,
          'langop.io/created-by': user.id,
        },
        annotations: {
          'langop.io/created-by-email': user.email!,
          'langop.io/created-at': new Date().toISOString(),
        },
      },
      spec: {
        displayName: formData.displayName,
        description: formData.description,
        systemPrompt: formData.systemPrompt,
        ...(formData.tone && { tone: formData.tone }),
        ...(formData.language && { language: formData.language }),
        ...(formData.version && { version: formData.version }),
        ...(formData.capabilities && formData.capabilities.length > 0 && { capabilities: formData.capabilities }),
        ...(formData.limitations && formData.limitations.length > 0 && { limitations: formData.limitations }),
        ...(formData.instructions && formData.instructions.length > 0 && { instructions: formData.instructions }),
        ...(formData.examples && formData.examples.length > 0 && {
          examples: formData.examples.map(ex => ({
            input: ex.input,
            output: ex.output,
            ...(ex.context && { context: ex.context }),
            ...(ex.tags && { tags: ex.tags }),
          })),
        }),
      },
    }

    const response = await k8sClient.createLanguagePersona(organization.namespace, persona)
    
    console.log(`User ${user.email} created LanguagePersona ${formData.name} in organization ${organization.name}`)

    return NextResponse.json({
      success: true,
      data: response.data,
    })

  } catch (error) {
    console.error('Error creating persona:', error)
    return NextResponse.json({ error: 'Failed to create persona' }, { status: 500 })
  }
}